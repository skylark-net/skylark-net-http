{"version":3,"sources":["upload.js"],"names":["define","types","objects","arrays","Deferred","Evented","Xhr","http","blobSlice","Blob","prototype","slice","webkitSlice","mozSlice","Upload","inherit","klassName","_construct","options","this","_options","mixin","debug","url","headers","maxConnections","maxChunkSize","undefined","onProgress","id","fileName","loaded","total","onComplete","result","status","xhr","onCancel","onFailure","e","_queue","_params","_files","_xhrs","_loaded","add","file","push","send","params","len","indexOf","copy","clone","_send","sendAll","length","cancel","_cancel","_dequeue","cancelAll","i","getName","name","getSize","fileSize","size","getLoaded","curUploadingSize","formData","chunkSize","curLoadedSize","args","self","data","call","type","formParamName","FormData","append","post","progress","lengthComputable","then","catch","abort","getQueue","inArray","max","splice","nextId","uploader","files"],"mappings":"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","file":"../upload.js","sourcesContent":["define([\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-objects\",\r\n    \"skylark-langx-arrays\",\r\n    \"skylark-langx-async/deferred\",\r\n    \"skylark-langx-emitter/evented\",    \r\n    \"./xhr\",\r\n    \"./http\"\r\n],function(types, objects, arrays, Deferred, Evented,Xhr, http){\r\n\r\n    var blobSlice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n\r\n\r\n    /*\r\n     *Class for uploading files using xhr.\r\n     */\r\n    var Upload = Evented.inherit({\r\n        klassName : \"Upload\",\r\n\r\n        _construct : function(options) {\r\n            this._options = objects.mixin({\r\n                debug: false,\r\n                url: '/upload',\r\n                headers : {\r\n\r\n                },\r\n                // maximum number of concurrent uploads\r\n                maxConnections: 999,\r\n                // To upload large files in smaller chunks, set the following option\r\n                // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n                // or the browser does not support the required Blob API, files will\r\n                // be uploaded as a whole.\r\n                maxChunkSize: undefined,\r\n\r\n                onProgress: function(id, fileName, loaded, total){\r\n                },\r\n                onComplete: function(id, fileName,result,status,xhr){\r\n                },\r\n                onCancel: function(id, fileName){\r\n                },\r\n                onFailure : function(id,fileName,e) {                    \r\n                }\r\n            },options);\r\n\r\n            this._queue = [];\r\n            // params for files in queue\r\n            this._params = [];\r\n\r\n            this._files = [];\r\n            this._xhrs = [];\r\n\r\n            // current loaded size in bytes for each file\r\n            this._loaded = [];\r\n\r\n        },\r\n\r\n        /**\r\n         * Adds file to the queue\r\n         * Returns id to use with upload, cancel\r\n         **/\r\n        add: function(file){\r\n            return this._files.push(file) - 1;\r\n        },\r\n\r\n        /**\r\n         * Sends the file identified by id and additional query params to the server.\r\n         */\r\n        send: function(id, params){\r\n            if (!this._files[id]) {\r\n                // Already sended or canceled\r\n                return ;\r\n            }\r\n            if (this._queue.indexOf(id)>-1) {\r\n                // Already in the queue\r\n                return;\r\n            }\r\n            var len = this._queue.push(id);\r\n\r\n            var copy = objects.clone(params);\r\n\r\n            this._params[id] = copy;\r\n\r\n            // if too many active uploads, wait...\r\n            if (len <= this._options.maxConnections){\r\n                this._send(id, this._params[id]);\r\n            }     \r\n        },\r\n\r\n        /**\r\n         * Sends all files  and additional query params to the server.\r\n         */\r\n        sendAll: function(params){\r\n           for( var id = 0; id <this._files.length; id++) {\r\n                this.send(id,params);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cancels file upload by id\r\n         */\r\n        cancel: function(id){\r\n            this._cancel(id);\r\n            this._dequeue(id);\r\n        },\r\n\r\n        /**\r\n         * Cancells all uploads\r\n         */\r\n        cancelAll: function(){\r\n            for (var i=0; i<this._queue.length; i++){\r\n                this._cancel(this._queue[i]);\r\n            }\r\n            this._queue = [];\r\n        },\r\n\r\n        getName: function(id){\r\n            var file = this._files[id];\r\n            return file.fileName != null ? file.fileName : file.name;\r\n        },\r\n\r\n        getSize: function(id){\r\n            var file = this._files[id];\r\n            return file.fileSize != null ? file.fileSize : file.size;\r\n        },\r\n\r\n        /**\r\n         * Returns uploaded bytes for file identified by id\r\n         */\r\n        getLoaded: function(id){\r\n            return this._loaded[id] || 0;\r\n        },\r\n\r\n\r\n        /**\r\n         * Sends the file identified by id and additional query params to the server\r\n         * @param {Object} params name-value string pairs\r\n         */\r\n        _send: function(id, params){\r\n            var options = this._options,\r\n                name = this.getName(id),\r\n                size = this.getSize(id),\r\n                chunkSize = options.maxChunkSize || 0,\r\n                curUploadingSize,\r\n                curLoadedSize = 0,\r\n                file = this._files[id],\r\n                args = {\r\n                    headers : objects.clone(options.headers)                    \r\n                };\r\n\r\n            this._loaded[id] = this._loaded[id] || 0;\r\n\r\n            var xhr = this._xhrs[id] = new Xhr({\r\n                url : options.url\r\n            });\r\n\r\n            if (chunkSize)  {\r\n\r\n                args.data = blobSlice.call(\r\n                    file,\r\n                    this._loaded[id],\r\n                    this._loaded[id] + chunkSize,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                curUploadingSize = args.data.size;\r\n                // Expose the chunk bytes position range:\r\n                args.headers[\"content-range\"] = 'bytes ' + this._loaded[id] + '-' +\r\n                    (this._loaded[id] + curUploadingSize - 1) + '/' + size;\r\n                args.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }  else {\r\n                curUploadingSize = size;\r\n                var formParamName =  params.formParamName,\r\n                    formData = params.formData;\r\n\r\n                if (formParamName) {\r\n                    if (!formData) {\r\n                        formData = new FormData();\r\n                    }\r\n                    formData.append(formParamName,file);\r\n                    args.data = formData;\r\n    \r\n                } else {\r\n                    args.headers[\"Content-Type\"] = file.type || \"application/octet-stream\";\r\n                    args.data = file;\r\n                }\r\n            }\r\n\r\n\r\n            var self = this;\r\n            xhr.post(\r\n                args\r\n            ).progress(function(e){\r\n                if (e.lengthComputable){\r\n                    curLoadedSize = curLoadedSize + e.loaded;\r\n                    self._loaded[id] = self._loaded[id] + e.loaded;\r\n                    self._options.onProgress(id, name, self._loaded[id], size);\r\n                }\r\n            }).then(function(result,status,xhr){\r\n                if (!self._files[id]) {\r\n                    // the request was aborted/cancelled\r\n                    return;\r\n                }\r\n\r\n                if (curLoadedSize < curUploadingSize) {\r\n                    // Create a progress event if no final progress event\r\n                    // with loaded equaling total has been triggered\r\n                    // for this chunk:\r\n                    self._loaded[id] = self._loaded[id] + curUploadingSize - curLoadedSize;\r\n                    self._options.onProgress(id, name, self._loaded[id], size);                    \r\n                }\r\n\r\n                if (self._loaded[id] <size) {\r\n                    // File upload not yet complete,\r\n                    // continue with the next chunk:\r\n                    self._send(id,params);\r\n                } else {\r\n                    self._options.onComplete(id,name,result,status,xhr);\r\n\r\n                    self._files[id] = null;\r\n                    self._xhrs[id] = null;\r\n                    self._dequeue(id);\r\n                }\r\n\r\n\r\n            }).catch(function(e){\r\n                self._options.onFailure(id,name,e);\r\n\r\n                self._files[id] = null;\r\n                self._xhrs[id] = null;\r\n                self._dequeue(id);\r\n            });\r\n        },\r\n\r\n        _cancel: function(id){\r\n            this._options.onCancel(id, this.getName(id));\r\n\r\n            this._files[id] = null;\r\n\r\n            if (this._xhrs[id]){\r\n                this._xhrs[id].abort();\r\n                this._xhrs[id] = null;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns id of files being uploaded or\r\n         * waiting for their turn\r\n         */\r\n        getQueue: function(){\r\n            return this._queue;\r\n        },\r\n\r\n\r\n        /**\r\n         * Removes element from queue, starts upload of next\r\n         */\r\n        _dequeue: function(id){\r\n            var i = arrays.inArray(id,this._queue);\r\n            this._queue.splice(i, 1);\r\n\r\n            var max = this._options.maxConnections;\r\n\r\n            if (this._queue.length >= max && i < max){\r\n                var nextId = this._queue[max-1];\r\n                this._send(nextId, this._params[nextId]);\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n  Upload.send = function(file, options) {\r\n    var uploader = new Upload(options);\r\n    var id = uploader.add(file);\r\n    return uploader.send(id,options);\r\n  };\r\n\r\n  Upload.sendAll = function(files,options) {\r\n      var uploader = new Upload(options);\r\n      for (var i = 0, len = files.length; i < len; i++) {\r\n        this.add(file[i]);\r\n      }\r\n      return uploader.send(options);\r\n  };\r\n\r\n    return http.Upload = Upload;    \r\n});"]}